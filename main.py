import os
import math
import asyncio
import logging
import re
import calendar as pycal
from datetime import date, timedelta
from typing import Final, Dict, Optional, Tuple, List

from fastapi import FastAPI, Request, HTTPException
from aiogram import Bot, Dispatcher, F
from aiogram.filters import CommandStart
from aiogram.types import (
    Update, Message, BotCommand, ReplyKeyboardMarkup, KeyboardButton,
    InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
)
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
import aiohttp

# ================== CONFIG ==================
BOT_TOKEN: Final[str] = os.getenv("BOT_TOKEN", "")
APP_BASE_URL: Final[str] = os.getenv("APP_BASE_URL", "").rstrip("/")
WEBHOOK_SECRET: Final[str] = os.getenv("WEBHOOK_SECRET", "")

ADMIN_CHAT_ID = int(os.getenv("ADMIN_CHAT_ID", "7039409310") or 7039409310)
DISPATCHER_PHONE = "+79340241414"
DISPATCHER_NAME = "–î–∏—Å–ø–µ—Ç—á–µ—Ä TransferAir"

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is not set")

# ================== LOGGING ==================
logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
logger = logging.getLogger("tgbot")

# ================== CORE ==================
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

# ================== BUTTONS ==================
BTN_START = "‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç"
BTN_CALC = "üßÆ –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä —Å—Ç–æ–∏–º–æ—Å—Ç–∏"
BTN_ORDER = "üìù –°–¥–µ–ª–∞—Ç—å –∑–∞–∫–∞–∑"
BTN_DISPATCHER = "‚òéÔ∏è –î–∏—Å–ø–µ—Ç—á–µ—Ä"
BTN_INFO = "‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"

MENU_BUTTONS = [BTN_CALC, BTN_ORDER, BTN_DISPATCHER, BTN_INFO]

# ================== MENU ==================
def start_big_button_kb() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text=BTN_START)]],
        resize_keyboard=True,
        is_persistent=True,
    )

def main_menu_kb() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=BTN_CALC)],
            [KeyboardButton(text=BTN_ORDER)],
            [KeyboardButton(text=BTN_DISPATCHER)],
            [KeyboardButton(text=BTN_INFO)],
        ],
        resize_keyboard=True,
        is_persistent=True,
    )

def dispatcher_inline_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(
            text="üí¨ –ù–∞–ø–∏—Å–∞—Ç—å –¥–∏—Å–ø–µ—Ç—á–µ—Ä—É –≤ Telegram",
            url="https://t.me/zhelektown"
        )
    ], [
        InlineKeyboardButton(
            text="üì± –¢–µ–ª–µ—Ñ–æ–Ω –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞",
            callback_data="dispatcher_phone"
        )
    ]])

# ================== STATES ==================
class DummyStates(StatesGroup):
    pass

# ================== COMMANDS ==================
@dp.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext):
    await state.clear()
    await message.answer(
        "*–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!*\n"
        "–≠—Ç–æ –±–æ—Ç –º–µ–∂–¥—É–≥–æ—Ä–æ–¥–Ω–µ–≥–æ —Ç–∞–∫—Å–∏ TransferAir –ö–∞–≤–∫–∞–∑—Å–∫–∏–µ –ú–∏–Ω–µ—Ä–∞–ª—å–Ω—ã–µ –í–æ–¥—ã.\n\n"
        "–ù–∞–∂–º–∏—Ç–µ *–°—Ç–∞—Ä—Ç*, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.",
        parse_mode="Markdown",
        reply_markup=start_big_button_kb(),
    )

@dp.message(F.text == BTN_START)
async def main_menu(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=main_menu_kb())

# ================== HANDLERS ==================
@dp.message(F.text == BTN_DISPATCHER)
async def dispatcher_menu(message: Message):
    text = (
        "‚òéÔ∏è *–°–≤—è–∑–∞—Ç—å—Å—è —Å –¥–∏—Å–ø–µ—Ç—á–µ—Ä–æ–º*\n\n"
        "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –Ω–∞–ø–∏—Å–∞—Ç—å –¥–∏—Å–ø–µ—Ç—á–µ—Ä—É –≤ Telegram\n"
        "–∏–ª–∏ –ø–æ–ª—É—á–∏—Ç—å –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –¥–ª—è –∑–≤–æ–Ω–∫–∞."
    )
    await message.answer(text, parse_mode="Markdown", reply_markup=dispatcher_inline_kb())

@dp.callback_query(F.data == "dispatcher_phone")
async def dispatcher_phone_cb(cb: CallbackQuery):
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–∞–∫—Ç (–Ω–æ–º–µ—Ä —Å—Ç–∞–Ω–µ—Ç –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–º)
    await bot.send_contact(
        chat_id=cb.message.chat.id,
        phone_number=DISPATCHER_PHONE,
        first_name=DISPATCHER_NAME,
    )
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–¥—É–±–ª–∏—Ä—É–µ–º –Ω–æ–º–µ—Ä –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏
    await bot.send_message(cb.message.chat.id, DISPATCHER_PHONE)
    await cb.answer("–ö–æ–Ω—Ç–∞–∫—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω")

@dp.message(F.text == BTN_INFO)
async def info_section(message: Message):
    await message.answer(
        "üöï TransferAir –º–µ–∂–¥—É–≥–æ—Ä–æ–¥–Ω–µ–µ —Ç–∞–∫—Å–∏ (–¢—Ä–∞–Ω—Å—Ñ–µ—Ä) –∏–∑ –ú–∏–Ω–µ—Ä–∞–ª—å–Ω—ã—Ö –í–æ–¥.\n\n"
        "ü§ñ –í—ã –º–æ–∂–µ—Ç–µ –∑–∞–∫–∞–∑–∞—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–µ—Ä —á–µ—Ä–µ–∑ —ç—Ç–æ–≥–æ –±–æ—Ç–∞.\n\n"
        "üìû –ü–æ–∑–≤–æ–Ω–∏—Ç—å –Ω–∞–º: +79340241414\n\n"
        "üåê –ü–æ—Å–µ—Ç–∏—Ç—å –Ω–∞—à —Å–∞–π—Ç: https://transferkmw.ru/",
    )
    # –ü–æ—Å–ª–µ —Ç–µ–∫—Å—Ç–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–∞–∫—Ç (–Ω–æ–º–µ—Ä –∫–ª–∏–∫–∞–±–µ–ª–µ–Ω)
    await bot.send_contact(message.chat.id, DISPATCHER_PHONE, DISPATCHER_NAME)
    await bot.send_message(message.chat.id, DISPATCHER_PHONE)

# ================== FASTAPI ==================
app = FastAPI()

@app.get("/")
async def healthcheck():
    return {"status": "ok"}

@app.post(f"/webhook/{{secret}}")
async def telegram_webhook(secret: str, request: Request):
    if WEBHOOK_SECRET and secret != WEBHOOK_SECRET:
        raise HTTPException(status_code=403, detail="forbidden")
    data = await request.json()
    update = Update.model_validate(data)
    await dp.feed_update(bot, update)
    return {"ok": True}

async def _set_webhook_with_retry():
    if not APP_BASE_URL:
        logger.warning("APP_BASE_URL –Ω–µ –∑–∞–¥–∞–Ω ‚Äî –≤–µ–±—Ö—É–∫ –Ω–µ –±—É–¥–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        return
    url = f"{APP_BASE_URL}/webhook/{WEBHOOK_SECRET or ''}".rstrip("/")
    while True:
        try:
            await bot.set_my_commands([BotCommand(command="start", description="–ó–∞–ø—É—Å–∫")])
            await bot.set_webhook(url=url, secret_token=WEBHOOK_SECRET or None, drop_pending_updates=True)
            logger.info("Webhook set to %s", url)
            break
        except Exception as e:
            logger.warning("Webhook not set yet (%s). Retrying soon‚Ä¶", e)
            await asyncio.sleep(30)

@app.on_event("startup")
async def on_startup():
    asyncio.create_task(_set_webhook_with_retry())
    logger.info("Startup complete. Waiting for webhook setup‚Ä¶")

@app.on_event("shutdown")
async def on_shutdown():
    try:
        await bot.delete_webhook(drop_pending_updates=False)
        logger.info("Webhook removed")
    except Exception as e:
        logger.warning(f"Failed to delete webhook: {e}")
